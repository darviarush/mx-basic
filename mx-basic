#!/usr/bin/env perl

use open qw/:std :utf8/;
use common::sense;

use Term::ReadLine;
use Term::ANSIColor qw(:constants);

my $term = new Term::ReadLine 'mx-basic';
my $prompt = RESET. CYAN. "üêà". RESET;
my $base = "src";
my $FILE = undef;


my %ACT = (
	"help" => "[—Ä–∞–∑–¥–µ–ª]	–ü–æ–º–æ—â—å",
	"new" =>  "–Ω–∞–∑–≤–∞–Ω–∏–µ	–°–æ–∑–¥–∞—Ç—å –º–µ—Ç–æ–¥",
	"open" => "–Ω–∞–∑–≤–∞–Ω–∏–µ	–û—Ç–∫—Ä—ã—Ç—å –º–µ—Ç–æ–¥",
	"list" => "[–æ—Ç][-–¥–æ]	–°–ø–∏—Å–æ–∫ —Å—Ç—Ä–æ–∫",
);

while ( defined($_ = $term->readline($prompt)) ) {
	next if /^\s*$/;

	if( /^(\d+)/ ) { save_line();	next; }

	for my $act (sort keys %ACT) {
		my $act_first = substr $act, 0, 1;
		if(/^($act_first|$act)(?:[^a-zA-Z]|$)/) {
			eval { &{"${act}_act"}(); };
			print RED, "$@", RESET, $@ =~ /\n$/? (): "\n" if $@;
			goto NEXT;
		}
	}

	print RED, "?", RESET, "\n";

	NEXT:;
}

sub help_act {
	if( /\s+/ ) {
		my $help = $';
		die "?\n" if !(my $h = $ACT{$help});
		my $man = $${"${help}_act"};
		print "`$help`\n";
		print "$help $h\n$man";
		return;
	}

	print "–ö–û–ú–ê–ù–î–´ –û–ë–û–õ–û–ß–ö–ò\n\n";
	print "$_ $ACT{$_}\n" for sort keys %ACT;
	print "\n"
}

our $new_act = '
	$ - —Å–æ–∑–¥–∞—Ç—å –∫–ª–∞—Å—Å $
	swap $, $ - —Å–æ–∑–¥–∞—Ç—å –º–µ—Ç–æ–¥ –≤ –∫–ª–∞—Å—Å–µ $ c –∞—Ä–≥—É–º–µ–Ω—Ç–æ–º –∫–ª–∞—Å—Å–∞ $
	sin#(#) - —Å–æ–∑–¥–∞—Ç—å –º–µ—Ç–æ–¥ sin –≤ –∫–ª–∞—Å—Å–µ # c –∞—Ä–≥—É–º–µ–Ω—Ç–æ–º –∫–ª–∞—Å—Å–∞ #
	#sin! - —Å–æ–∑–¥–∞—Ç—å –º–µ—Ç–æ–¥ –≤ –∫–ª–∞—Å—Å–µ # c –∞—Ä–≥—É–º–µ–Ω—Ç–æ–º –∫–ª–∞—Å—Å–∞ !
	(-)# - —É –∫–ª–∞—Å—Å–∞ # —Å–¥–µ–ª–∞—Ç—å –ª–µ–≤–æ—Å—Ç–æ—Ä–æ–Ω–Ω–∏–π —É–Ω–∞—Ä–Ω—ã–π –º–µ—Ç–æ–¥-–æ–ø–µ—Ä–∞—Ç–æ—Ä -
	$(#) - —É –∫–ª–∞—Å—Å–∞ $ —Å–¥–µ–ª–∞—Ç—å –ø—Ä–∞–≤–æ—Å—Ç–æ—Ä–æ–Ω–Ω–∏–π —É–Ω–∞—Ä–Ω—ã–π –º–µ—Ç–æ–¥-–æ–ø–µ—Ä–∞—Ç–æ—Ä #
	!(+)# - —É –∫–ª–∞—Å—Å–∞ ! —Å–¥–µ–ª–∞—Ç—å –±–∏–Ω–∞—Ä–Ω—ã–π –º–µ—Ç–æ–¥-–æ–ø–µ—Ä–∞—Ç–æ—Ä + c –∞—Ä–≥—É–º–µ–Ω—Ç–æ–º –∫–ª–∞—Å—Å–∞ #
';
my $RE_OP = qr/[^\w\s,;:(){}\[\]]/;
sub method_get {
	my ($class, $method, @args);
	local ($_) = @_;
	if( /^($RE_OP)$/ ) { $class = $_ }
	elsif( /^(\w+)\s*(.*)$/ ) {
		$method = $1;
		@args = split /\s*,\s*/, $2;
		die "–ù–µ —É–∫–∞–∑–∞–Ω –∫–ª–∞—Å—Å.\n" if !@args;
		for(@args) { die "–ê—Ä–≥—É–º–µ–Ω—Ç `$_` - –Ω–µ –∫–ª–∞—Å—Å." if !/^$RE_OP$/ }
		$class = pop @args;
	}
	else { die "?\n" }
	return $class, $method, @args;
}

sub method_file {
	my ($class, $method, @args) = @_;
	return "$class/\$" if !defined $method;
	"$class/$method@args"
}

sub new_act {
	my $file = method_file(@_);
	die "–°—É—â–µ—Å—Ç–≤—É–µ—Ç.\n" if -e $file;
	open my $f, ">", $file or die "$file: $!\n";
	close $f;
	$FILE = $file;
}

sub open_act {
	my $file = method_file(@_);
	die "–ù–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç.\n" if !-f $file;
	open my $f, "<", $file or die "$file: $!\n";
	close $f;
	$FILE = $file;
}

sub list_act {
	die "?\n" if !/^[a-z]+\s*(\d*)(?:-(\d*))?\s*$/i;
	my ($from, $to) = ($1, $2);

	$to = "inf" if $to == 0;

	open my $f, "<", $FILE or die "$FILE: $!";
	while(<$f>) {
		my ($n) = /^\d+/;
		print if $from <= $n;
		last if $n >= $to;
	}
	close $f;
}